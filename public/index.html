<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#0a84ff" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Greep SDS" />
    <meta name="msapplication-TileColor" content="#0a84ff" />
    <meta name="msapplication-tap-highlight" content="no" />

    <!-- PWA Meta Tags -->
    <meta name="application-name" content="Greep SDS" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="format-detection" content="telephone=no" />

    <!-- <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:;
    script-src 'self' 'unsafe-inline' 'unsafe-eval';
    style-src 'self' 'unsafe-inline';
    connect-src 'self' http://localhost:3001 https://api-student-delivery.greep.io https://*.greep.io wss://api-student-delivery.greep.io wss://*.greep.io;
    object-src 'none';
  "
    /> -->
    <meta
      name="description"
      content="Student Delivery System - Modern OTP-based delivery management. Connect students with delivery opportunities."
    />

    <!-- PWA Icons -->
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/icons/icon-192x192.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="%PUBLIC_URL%/icons/icon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="%PUBLIC_URL%/icons/icon-16x16.png"
    />
    <link
      rel="mask-icon"
      href="%PUBLIC_URL%/icons/icon-192x192.png"
      color="#0a84ff"
    />

    <!-- PWA Manifest -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>Greep SDS</title>
    <script>
      // PERMANENT FIX: Block postMessage errors BEFORE anything else loads
      (function () {
        "use strict";

        // Store original postMessage
        const originalPostMessage = window.postMessage;

        // Create intelligent wrapper function - only block problematic calls
        function safePostMessage(message, targetOrigin, transfer) {
          try {
            // Block MetaMask messages
            if (
              message &&
              typeof message === "object" &&
              message.type &&
              (message.type.includes("metamask") ||
                message.type.includes("ethereum"))
            ) {
              console.warn("MetaMask message blocked:", message.type);
              return;
            }

            // INTELLIGENT BLOCKING: Only block calls that will definitely cause errors
            if (
              targetOrigin === "undefined" || // String "undefined" - definitely problematic
              targetOrigin === "null" // String "null" - definitely problematic
            ) {
              console.warn(
                "üö´ Blocked postMessage with problematic targetOrigin:",
                targetOrigin
              );
              return;
            }

            // ALLOW calls with undefined/null targetOrigin but handle them safely
            if (
              !targetOrigin ||
              targetOrigin === undefined ||
              targetOrigin === null
            ) {
              console.log(
                "‚ö†Ô∏è Allowing postMessage with undefined/null targetOrigin (will use default):",
                targetOrigin
              );
              // Call with default targetOrigin instead of blocking
              return originalPostMessage.call(
                this,
                message,
                "*", // Use wildcard as safe default
                transfer
              );
            }

            // Additional type safety - but allow non-string with safe fallback
            if (typeof targetOrigin !== "string") {
              console.log(
                "‚ö†Ô∏è Allowing postMessage with non-string targetOrigin (will use default):",
                typeof targetOrigin,
                targetOrigin
              );
              // Call with default targetOrigin instead of blocking
              return originalPostMessage.call(
                this,
                message,
                "*", // Use wildcard as safe default
                transfer
              );
            }

            // Safe to call postMessage with original targetOrigin
            return originalPostMessage.call(
              this,
              message,
              targetOrigin,
              transfer
            );
          } catch (error) {
            console.warn(
              "‚ö†Ô∏è postMessage error caught but allowing to continue:",
              error.message
            );
            // Don't block - let it continue
            return;
          }
        }

        // Override at multiple levels to ensure nothing gets through
        window.postMessage = safePostMessage;

        // Also override at prototype level
        if (window.MessageEvent && window.MessageEvent.prototype) {
          const originalPostMessageProto =
            window.MessageEvent.prototype.postMessage;
          if (originalPostMessageProto) {
            window.MessageEvent.prototype.postMessage = safePostMessage;
          }
        }

        // Make it non-writable and non-configurable
        Object.defineProperty(window, "postMessage", {
          value: safePostMessage,
          writable: false,
          configurable: false,
        });

        console.log(
          "üõ°Ô∏è INTELLIGENT postMessage protection activated - allowing legitimate calls"
        );
      })();

      // Suppress React Router future flag warnings
      const originalWarn = console.warn;
      console.warn = function (...args) {
        const message = args[0];
        if (
          typeof message === "string" &&
          (message.includes("React Router Future Flag Warning") ||
            message.includes("v7_startTransition") ||
            message.includes("v7_relativeSplatPath"))
        ) {
          return;
        }
        originalWarn.apply(console, args);
      };

      // Block MetaMask connections
      if (typeof window !== "undefined") {
        // Override ethereum object to prevent MetaMask connections
        Object.defineProperty(window, "ethereum", {
          get: function () {
            console.warn("MetaMask connection blocked");
            return undefined;
          },
          set: function () {
            console.warn("MetaMask connection blocked");
          },
        });
      }

      // INTELLIGENT ERROR HANDLING: Log errors but don't block functionality
      window.addEventListener("error", function (event) {
        if (
          event.error &&
          event.error.message &&
          event.error.message.includes("postMessage")
        ) {
          console.log(
            "‚ö†Ô∏è postMessage error detected (allowing to continue):",
            event.error.message
          );
          // Don't prevent default - let it continue
        }
      });

      window.addEventListener("unhandledrejection", function (event) {
        if (
          event.reason &&
          event.reason.message &&
          event.reason.message.includes("postMessage")
        ) {
          console.log(
            "‚ö†Ô∏è postMessage promise rejection detected (allowing to continue):",
            event.reason.message
          );
          // Don't prevent default - let it continue
        }
      });

      // Block MetaMask extension messages and handle invalid postMessage calls
      const originalPostMessage = window.postMessage;
      window.postMessage = function (message, targetOrigin, transfer) {
        // Log all postMessage calls for debugging
        console.log("üîç postMessage called with:", {
          message,
          targetOrigin,
          transfer,
        });

        try {
          // Block MetaMask messages
          if (
            message &&
            typeof message === "object" &&
            message.type &&
            (message.type.includes("metamask") ||
              message.type.includes("ethereum"))
          ) {
            console.warn("MetaMask message blocked:", message.type);
            return;
          }

          // Validate targetOrigin before calling postMessage
          if (
            !targetOrigin ||
            targetOrigin === "undefined" ||
            targetOrigin === "null"
          ) {
            console.warn(
              "‚ö†Ô∏è Blocked postMessage with invalid targetOrigin:",
              targetOrigin
            );
            return;
          }

          // Additional safety checks
          if (typeof targetOrigin !== "string" || targetOrigin.trim() === "") {
            console.warn(
              "‚ö†Ô∏è Blocked postMessage with non-string targetOrigin:",
              targetOrigin
            );
            return;
          }

          // Safe to call postMessage
          console.log(
            "‚úÖ postMessage call allowed with valid targetOrigin:",
            targetOrigin
          );
          return originalPostMessage.call(
            this,
            message,
            targetOrigin,
            transfer
          );
        } catch (error) {
          console.warn(
            "‚ö†Ô∏è postMessage error caught and prevented:",
            error.message
          );
          return;
        }
      };

      // Add global error handler for postMessage errors
      window.addEventListener("error", function (event) {
        console.log("üîç Global error event:", event);

        if (
          event.error &&
          event.error.message &&
          event.error.message.includes("postMessage")
        ) {
          console.warn(
            "‚ö†Ô∏è Global postMessage error caught:",
            event.error.message
          );
          event.preventDefault();
          return false;
        }

        // Also catch any SyntaxError related to postMessage
        if (event.message && event.message.includes("postMessage")) {
          console.warn(
            "‚ö†Ô∏è Global postMessage syntax error caught:",
            event.message
          );
          event.preventDefault();
          return false;
        }
      });

      // Also handle unhandled promise rejections
      window.addEventListener("unhandledrejection", function (event) {
        if (
          event.reason &&
          event.reason.message &&
          event.reason.message.includes("postMessage")
        ) {
          console.warn(
            "‚ö†Ô∏è Global postMessage promise rejection caught:",
            event.reason.message
          );
          event.preventDefault();
          return false;
        }
      });

      // Additional safety: Override postMessage at prototype level
      if (window.MessageEvent && window.MessageEvent.prototype) {
        const originalPostMessageProto =
          window.MessageEvent.prototype.postMessage;
        if (originalPostMessageProto) {
          window.MessageEvent.prototype.postMessage = function (
            message,
            targetOrigin,
            transfer
          ) {
            console.log("üîç MessageEvent postMessage called with:", {
              message,
              targetOrigin,
              transfer,
            });

            if (
              !targetOrigin ||
              targetOrigin === "undefined" ||
              targetOrigin === "null"
            ) {
              console.warn(
                "‚ö†Ô∏è Blocked MessageEvent postMessage with invalid targetOrigin:",
                targetOrigin
              );
              return;
            }

            try {
              return originalPostMessageProto.call(
                this,
                message,
                targetOrigin,
                transfer
              );
            } catch (error) {
              console.warn(
                "‚ö†Ô∏è MessageEvent postMessage error caught:",
                error.message
              );
              return;
            }
          };
        }
      }

      // Final safety: Monitor for any postMessage calls
      console.log("üõ°Ô∏è postMessage protection activated successfully");
    </script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>

    <!-- PWA Service Worker Registration -->
    <script>
      // Register Service Worker for PWA functionality
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/service-worker.js")
            .then((registration) => {
              console.log(
                "‚úÖ PWA Service Worker registered successfully:",
                registration.scope
              );

              // Check for updates
              registration.addEventListener("updatefound", () => {
                const newWorker = registration.installing;
                newWorker.addEventListener("statechange", () => {
                  if (
                    newWorker.state === "installed" &&
                    navigator.serviceWorker.controller
                  ) {
                    // New content is available, show update notification
                    if (confirm("New version available! Reload to update?")) {
                      window.location.reload();
                    }
                  }
                });
              });
            })
            .catch((error) => {
              console.error(
                "‚ùå PWA Service Worker registration failed:",
                error
              );
            });
        });
      }

      // PWA Install Prompt
      let deferredPrompt;
      window.addEventListener("beforeinstallprompt", (e) => {
        console.log("üì± PWA Install prompt triggered");
        e.preventDefault();
        deferredPrompt = e;

        // Show install button or notification
        const installButton = document.createElement("button");
        installButton.textContent = "Install App";
        installButton.style.cssText = `
          position: fixed;
          bottom: 20px;
          right: 20px;
          background: #0a84ff;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 25px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(10, 132, 255, 0.3);
          z-index: 1000;
          transition: all 0.3s ease;
        `;

        installButton.addEventListener("click", () => {
          deferredPrompt.prompt();
          deferredPrompt.userChoice.then((choiceResult) => {
            if (choiceResult.outcome === "accepted") {
              console.log("‚úÖ PWA installed successfully");
            } else {
              console.log("‚ùå PWA installation declined");
            }
            deferredPrompt = null;
            installButton.remove();
          });
        });

        document.body.appendChild(installButton);

        // Auto-hide after 10 seconds
        setTimeout(() => {
          if (installButton.parentNode) {
            installButton.remove();
          }
        }, 10000);
      });

      // PWA Installed Event
      window.addEventListener("appinstalled", () => {
        console.log("üéâ PWA installed successfully!");
        // Hide install button if it exists
        const installButton = document.querySelector(
          'button[style*="position: fixed"]'
        );
        if (installButton) {
          installButton.remove();
        }
      });

      // Online/Offline Status
      window.addEventListener("online", () => {
        console.log("üåê App is back online");
        // Show online notification
        if (navigator.serviceWorker.controller) {
          navigator.serviceWorker.controller.postMessage({ type: "ONLINE" });
        }
      });

      window.addEventListener("offline", () => {
        console.log("üì¥ App is offline");
        // Show offline notification
        if (navigator.serviceWorker.controller) {
          navigator.serviceWorker.controller.postMessage({ type: "OFFLINE" });
        }
      });

      // PWA Update Available
      navigator.serviceWorker.addEventListener("controllerchange", () => {
        console.log("üîÑ PWA controller changed - new version active");
        window.location.reload();
      });
    </script>
  </body>
</html>
